#include <Wire.h>// Adafruit Unified Sensor - Version: Latest //provides a common 'type' for sensor data and some helper functions#include <Adafruit_Sensor.h>// Adafruit BNO055 - Version: Latest #include <Adafruit_BNO055.h>#include <utility/imumaths.h>#include <EEPROM.h>/* BNO055 Xplained Pro Extension Kit (Atmel) layout:=================================================   PIN5  - I2C_ADDR_SEL   PIN6  - LED_G   PIN7  - LED_B   PIN8  - LED_R   PIN9  - INT   *PIN11 - SDA   *PIN12 - SCL   PIN15 - RESET   PIN19 - GND   PIN20 - VCC_3V3   BNO055 Xplained Pro Extension Kit (Atmel) connections to Arduino================================================================      Connections to Arduino UNO         Connections to Arduino MEGA   --------------------------         --------------------------   Connect SCL to analog 5            Connect SCL(PIN12) to digital 21   Connect SDA to analog 4            Connect SDA(PIN11) to digital 20   Connect VCC_3V3 to 3.3 DC          Connect VCC_3V3(PIN20) to 3.3 DC   Connect GND to common ground       Connect GND(PIN19) to common ground                                      Connect LED_G(PIN6) to digital 3                                      Connect LED_B(PIN7) to digital 4                                      Connect LED_R(PIN8) to digital 2                                        - pushbutton attached to pin 8 from +5V  - 10K resistor attached to pin 8 from ground      ***Update history***               ver1   -- text frame transmission               ver3   -- binary frame transmission               ver3.1 -- calibration button  21/12/2020 - ver4   -- gravity vector   23/12/2020 - ver5   -- axis remap, euler angles(sensor)   05/02/2021 - ver6   -- Operating mode: IMU (relative orientation). Previously operating mode: NDOF (absolute orientation) */float xPos = 0, yPos = 0, zPos = 0, xVel = 0, yVel = 0, zVel = 0, headingVel = 0;uint16_t BNO055_SAMPLERATE_DELAY_MS = 10; //how often to read data from the boarduint16_t PRINT_DELAY_MS = 100; // how often to print the datauint16_t printCount = 0; //counter to avoid printing every 10MS sample//velocity = accel*dt (dt in seconds)//position = 0.5*accel*dt^2float ACCEL_VEL_TRANSITION =  (float)(BNO055_SAMPLERATE_DELAY_MS) / 1000.0;float ACCEL_POS_TRANSITION = 0.5 * ACCEL_VEL_TRANSITION * ACCEL_VEL_TRANSITION;float DEG_2_RAD = 0.01745329251; //trig functions require radians, BNO055 outputs degreesTwoWire *_wire = &Wire;uint8_t address = 0x29;// Check I2C device address and correct line below (by default address is 0x29 or 0x28)//                                   id, addressAdafruit_BNO055 bno = Adafruit_BNO055(55, address);//the default I2C address of the BNO055 device is 0x029                                                                        // Pin definitionsconst int RedLed  = 2;  const int GreenLed  = 3;const int BlueLed  = 4;const int PushButton = 8;     // the number of the pushbutton pintypedef union { float floatingPoint; byte binary[4];} binaryFloat;int buttonState = 0;         // variable for reading the pushbutton status/* Write sensor data over serial port */void sendBinFrame(void) {    Serial.write("BF");          //quaternion  imu::Quaternion quat = bno.getQuat();  binaryFloat qW, qX, qY, qZ;    qW.floatingPoint = quat.w();     Serial.write(qW.binary,4);      qX.floatingPoint = quat.x();     Serial.write(qX.binary,4);    qY.floatingPoint = quat.y();     Serial.write(qY.binary,4);    qZ.floatingPoint = quat.z();    Serial.write(qZ.binary,4);    //Euler angles - degrees  sensors_event_t orientationData;                                 bno.getEvent(&orientationData); // equivale a: bno.getEvent(&orientationData, Adafruit_BNO055::VECTOR_EULER);       binaryFloat yaw, pitch, roll;      yaw.floatingPoint = orientationData.orientation.x;    Serial.write(yaw.binary,4);  pitch.floatingPoint = orientationData.orientation.y;    Serial.write(pitch.binary,4);  roll.floatingPoint = orientationData.orientation.z;   Serial.write(roll.binary,4);      //Gravity vector - m/s^2  imu::Vector<3> v_gravity = bno.getVector(Adafruit_BNO055::VECTOR_GRAVITY);  binaryFloat gravity_x, gravity_y, gravity_z;         gravity_x.floatingPoint = v_gravity.x();    Serial.write(gravity_x.binary,4);  gravity_y.floatingPoint = v_gravity.y();   Serial.write(gravity_y.binary,4);  gravity_z.floatingPoint = v_gravity.z();    Serial.write(gravity_z.binary,4);    //calibration status  uint8_t sys, gyro, accel, mag;  sys = gyro = accel = mag = 0;  bno.getCalibration(&sys, &gyro, &accel, &mag);      Serial.write(sys);  Serial.write(accel);  Serial.write(gyro);    Serial.write(mag);  }/* Changes the chip's axis remap */void setAxisRemap(uint8_t remapcode){    //adafruit_bno055_opmode_t modeback = _mode;    bno.setMode(Adafruit_BNO055::OPERATION_MODE_CONFIG);  delay(25);  write8(Adafruit_BNO055::BNO055_AXIS_MAP_CONFIG_ADDR, remapcode);  delay(10);  /* Set the requested operating mode (see section 3.3 of BNO055 datasheet) */  bno.setMode(Adafruit_BNO055::OPERATION_MODE_NDOF);  delay(20); }/* Changes the chip's axis signs */void setAxisSign(uint8_t remapsign) {  //adafruit_bno055_opmode_t modeback = _mode;  bno.setMode(Adafruit_BNO055::OPERATION_MODE_CONFIG);  delay(25);  write8(Adafruit_BNO055::BNO055_AXIS_MAP_SIGN_ADDR, remapsign);  delay(10);  /* Set the requested operating mode (see section 3.3 of BNO055 datasheet) */  bno.setMode(Adafruit_BNO055::OPERATION_MODE_NDOF);  delay(20);}/* Writes an 8 bit value over I2C */bool write8(Adafruit_BNO055::adafruit_bno055_reg_t reg, byte value) {    _wire->beginTransmission(address);#if ARDUINO >= 100  //if the IDE version is greater or equal 1.00  _wire->write((uint8_t)reg);  _wire->write((uint8_t)value);#else  _wire->send(reg);  _wire->send(value);#endif  _wire->endTransmission();  /*Check for error! */  return true;}/**************************************************************************//*    Arduino setup function (automatically called at startup)*//**************************************************************************/void setup(void){  pinMode(RedLed, OUTPUT); //Pin configured as OUTPUT (low-impedance state)  pinMode(BlueLed, OUTPUT);  pinMode(GreenLed, OUTPUT);  pinMode(PushButton, INPUT); // Pin configured as INPUT    digitalWrite(RedLed, HIGH); // turn the LEDs off (LOW is the active voltage level)  digitalWrite(BlueLed, HIGH);  digitalWrite(GreenLed, HIGH);    Serial.begin(115200);   //while(!Serial){};  delay(1000);    //Orientation Sensor Test    /* Initialise the sensor */  if (!bno.begin(Adafruit_BNO055::OPERATION_MODE_IMUPLUS))  {    //No BNO055 detected    while (1)    {        digitalWrite(RedLed, LOW);        // turn the RED LED on (LOW is the active voltage level)        digitalWrite(BlueLed, HIGH);        digitalWrite(GreenLed, HIGH);        delay(1000);                       // wait for a second        digitalWrite(RedLed, HIGH);        // turn the RED LED off         digitalWrite(BlueLed, HIGH);        digitalWrite(GreenLed, HIGH);        delay(1000);                       // wait for a second    }  }    int eeAddress = 0;  long bnoID;  bool foundCalib = false;  EEPROM.get(eeAddress, bnoID);  adafruit_bno055_offsets_t calibrationData;  sensor_t sensor;  /*  *  Look for the sensor's unique ID at the beginning oF EEPROM.  *  This isn't foolproof, but it's better than nothing.  */  bno.getSensor(&sensor);  if (bnoID != sensor.sensor_id)  {    //No Calibration Data for this sensor exists in EEPROM    delay(500);  }  else  {    //Found Calibration for this sensor in EEPROM    eeAddress += sizeof(long);    EEPROM.get(eeAddress, calibrationData);    //displaySensorOffsets(calibrationData);    //Restoring Calibration data to the BNO055    bno.setSensorOffsets(calibrationData);    //Calibration data loaded into BNO055    foundCalib = true;  }  delay(1000);  /* Crystal must be configured AFTER loading calibration data into BNO055. */  bno.setExtCrystalUse(true);     sensors_event_t event; //used to return sensor data from any sensor supported by the abstraction layer, using standard SI                          //units and scales     bno.getEvent(&event); //will populate the supplied sensors_event_t reference with the latest available sensor data  /* always recal the mag as It goes out of calibration very often */    if (foundCalib){    //Move sensor slightly to calibrate magnetometers    while (!bno.isFullyCalibrated())    {      //bno.getEvent(&event);             //delay(BNO055_SAMPLERATE_DELAY_MS); //Wait the specified delay before requesting new data            digitalWrite(RedLed, LOW); // turn the RED LED on (LOW is the active voltage level)      digitalWrite(BlueLed, HIGH);      digitalWrite(GreenLed, HIGH);            sendBinFrame();      delay(BNO055_SAMPLERATE_DELAY_MS);    }  }  else  {    //Calibrate Sensor    while (!bno.isFullyCalibrated())    {      //bno.getEvent(&event);       //delay(BNO055_SAMPLERATE_DELAY_MS); //Wait the specified delay before requesting new data                  digitalWrite(RedLed, LOW); // turn the RED LED on (LOW is the active voltage level)      digitalWrite(BlueLed, HIGH);      digitalWrite(GreenLed, HIGH);            sendBinFrame();      delay(BNO055_SAMPLERATE_DELAY_MS);    }  }    //Fully calibrated!  digitalWrite(RedLed, HIGH);   digitalWrite(BlueLed, LOW);  // turn the BLUE LED on (LOW is the voltage level)  digitalWrite(GreenLed, HIGH);     //--------------------------------  //Calibration Results  adafruit_bno055_offsets_t newCalib;  bno.getSensorOffsets(newCalib);   //Storing calibration data to EEPROM  eeAddress = 0;  bno.getSensor(&sensor);  bnoID = sensor.sensor_id;  EEPROM.put(eeAddress, bnoID);  eeAddress += sizeof(long);  EEPROM.put(eeAddress, newCalib);  //Data stored to EEPROM      //Set axis remap  setAxisRemap(0x24); //0x24 = default value  //Set axis signs  setAxisSign(0x00);  //0x00 = default value    //Para la configuración específica que necesitaba Debora inicialmente: setAxisRemap(0x012) y setAxisSign(0x00);    delay(1000);   }/**************************************************************************//*    Arduino loop function, called once 'setup' is complete (your own code    should go here)*//**************************************************************************/// Possible vector values can be:  // - VECTOR_ACCELEROMETER - m/s^2  // - VECTOR_MAGNETOMETER  - uT  // - VECTOR_GYROSCOPE     - rad/s  // - VECTOR_EULER         - degrees  // - VECTOR_LINEARACCEL   - m/s^2  // - VECTOR_GRAVITY       - m/s^2  void loop(void){  unsigned long tStart = micros();    digitalWrite(RedLed, HIGH);   digitalWrite(BlueLed, HIGH);  digitalWrite(GreenLed, LOW);   // turn the GREEN LED on (LOW is the voltage level)    //¡¡¡¡comentar hasta que se indique más abajo, si el pushbutton de recalibración no está conectado!!!    // read the state of the pushbutton value:  buttonState = digitalRead(PushButton);  // check if the pushbutton attached to pin 8 is pressed. If it is, recalibrate the sensor  if (buttonState == HIGH) {        digitalWrite(RedLed, LOW); // turn the RED LED on (LOW is the active voltage level)    digitalWrite(BlueLed, HIGH);    digitalWrite(GreenLed, HIGH);        // Recalibrate the sensor    while (!bno.isFullyCalibrated())    {      sensors_event_t event;      bno.getEvent(&event);       delay(BNO055_SAMPLERATE_DELAY_MS);                  sendBinFrame();      delay(BNO055_SAMPLERATE_DELAY_MS);    }         adafruit_bno055_offsets_t newCalib;    bno.getSensorOffsets(newCalib);        //Storing calibration data to EEPROM    int eeAddress = 0;    sensor_t sensor;    bno.getSensor(&sensor);    long bnoID = sensor.sensor_id;    EEPROM.put(eeAddress, bnoID);    eeAddress += sizeof(long);    EEPROM.put(eeAddress, newCalib);        delay(500);  }    //¡¡¡¡comentar hasta aquí, si el pushbutton de recalibración no está conectado!!!    if (printCount * BNO055_SAMPLERATE_DELAY_MS >= PRINT_DELAY_MS) {    //enough iterations have passed that we can print the latest data           sendBinFrame();            printCount = 0;  }  else {    printCount = printCount + 1;  }  while ((micros() - tStart) < (BNO055_SAMPLERATE_DELAY_MS * 1000))  {    //poll until the next sample is ready  }}